/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.12.v202002200719.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V1_GREATWALL_DVR_VIMS_DVR_File_Operation_PROXY_HPP_
#define V1_GREATWALL_DVR_VIMS_DVR_File_Operation_PROXY_HPP_

#include <v1/GREATWALL/DVR_VIMS/DVRFileOperationProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace GREATWALL {
namespace DVR_VIMS {

template <typename ... _AttributeExtensions>
class DVRFileOperationProxy
    : virtual public DVRFileOperation,
      virtual public DVRFileOperationProxyBase,
      virtual public _AttributeExtensions... {
public:
    DVRFileOperationProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~DVRFileOperationProxy();

    typedef DVRFileOperation InterfaceType;




    /**
     * Calls AllFileDeleteRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void AllFileDeleteRequest(const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_FileDeleteACK, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls AllFileDeleteRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> AllFileDeleteRequestAsync(const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, AllFileDeleteRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls FileListRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void FileListRequest(const DVRFileOperation::FileType &_FileType, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileNumber &_FileNumber, const DVRFileOperation::FileName &_FileName, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::FileListStructArray &_FileListStructArray, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls FileListRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> FileListRequestAsync(const DVRFileOperation::FileType &_FileType, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileNumber &_FileNumber, const DVRFileOperation::FileName &_FileName, FileListRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls AllFileExportRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void AllFileExportRequest(const DVRFileOperation::ExportMode &_ExportMode, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::ExportFileACK &_ExportFileACK, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls AllFileExportRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> AllFileExportRequestAsync(const DVRFileOperation::ExportMode &_ExportMode, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, AllFileExportRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls FileExportRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void FileExportRequest(const DVRFileOperation::ExportMode &_ExportMode, const DVRFileOperation::FileListPath &_FileListPath, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::ExportFileACK &_ExportFileACK, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls FileExportRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> FileExportRequestAsync(const DVRFileOperation::ExportMode &_ExportMode, const DVRFileOperation::FileListPath &_FileListPath, FileExportRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls AsyncAllFileDeleteRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void AsyncAllFileDeleteRequest(const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_FileDeleteACK, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls AsyncAllFileDeleteRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> AsyncAllFileDeleteRequestAsync(const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, AsyncAllFileDeleteRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls DVRFileCapacityInfoReq with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void DVRFileCapacityInfoReq(const DVRFileOperation::TFAllFileCapacity_Enum &_TFAllFileCapacity, const DVRFileOperation::TFCardFileTypeList_Array &_TFCardFileTypeList, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::FileCapacityList_Array &_FileCapacityList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls DVRFileCapacityInfoReq with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> DVRFileCapacityInfoReqAsync(const DVRFileOperation::TFAllFileCapacity_Enum &_TFAllFileCapacity, const DVRFileOperation::TFCardFileTypeList_Array &_TFCardFileTypeList, DVRFileCapacityInfoReqAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SDCardFormat with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SDCardFormat(const DVRFileOperation::SDCardOption &_SDCardOption, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_TFCardFormatACK, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SDCardFormat with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SDCardFormatAsync(const DVRFileOperation::SDCardOption &_SDCardOption, SDCardFormatAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls StartVideoBrowse with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void StartVideoBrowse(const DVRFileOperation::AccessType &_VideoBrowseChannel, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_VideoBrowseACK, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls StartVideoBrowse with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> StartVideoBrowseAsync(const DVRFileOperation::AccessType &_VideoBrowseChannel, StartVideoBrowseAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls FileListIncludeDateReq with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void FileListIncludeDateReq(const DVRFileOperation::FileType &_FileType, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileNumber &_FileNumber, const DVRFileOperation::FileName &_FileName, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::FileListIncludeDate_Array &_FileListIncludeDate, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls FileListIncludeDateReq with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> FileListIncludeDateReqAsync(const DVRFileOperation::FileType &_FileType, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileNumber &_FileNumber, const DVRFileOperation::FileName &_FileName, FileListIncludeDateReqAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls FileDeleteRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void FileDeleteRequest(const DVRFileOperation::FileListPath &_FileListPath, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_FileDeleteACK, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls FileDeleteRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> FileDeleteRequestAsync(const DVRFileOperation::FileListPath &_FileListPath, FileDeleteRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls TFCardInfoQuery with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void TFCardInfoQuery(const DVRFileOperation::GetAllInfo &_GetAllInfo, const DVRFileOperation::TFCardOptionList &_TFCardOptionList, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::TFCardInfoList &_TFCardInfoList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls TFCardInfoQuery with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> TFCardInfoQueryAsync(const DVRFileOperation::GetAllInfo &_GetAllInfo, const DVRFileOperation::TFCardOptionList &_TFCardOptionList, TFCardInfoQueryAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SelectFileCapacityRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SelectFileCapacityRequest(const DVRFileOperation::FileListPath &_FileListPath, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_SetResult, DVRFileOperation::FileCapacity &_FileCapacity, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SelectFileCapacityRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SelectFileCapacityRequestAsync(const DVRFileOperation::FileListPath &_FileListPath, SelectFileCapacityRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls EMMCInfoQuery with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void EMMCInfoQuery(const DVRFileOperation::GetAllInfo &_GetAllInfo, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::EMMCStatus &_EMMCStatus, DVRFileOperation::EMMCCapacityStruct &_EMMCCapacityStruct, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls EMMCInfoQuery with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> EMMCInfoQueryAsync(const DVRFileOperation::GetAllInfo &_GetAllInfo, EMMCInfoQueryAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls StopVideoBrowse with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void StopVideoBrowse(const DVRFileOperation::AccessType &_VideoBrowseChannel, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_VideoBrowseACK, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls StopVideoBrowse with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> StopVideoBrowseAsync(const DVRFileOperation::AccessType &_VideoBrowseChannel, StopVideoBrowseAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SelectAllFileCapacityRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SelectAllFileCapacityRequest(const DVRFileOperation::AccessType &_AccessType_In, const DVRFileOperation::FileType &_FileType_In, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::AccessType &_AccessType_Out, DVRFileOperation::FileType &_FileType_Out, DVRFileOperation::SelectAllFileCapacity &_SelectAllFileCapacity, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SelectAllFileCapacityRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SelectAllFileCapacityRequestAsync(const DVRFileOperation::AccessType &_AccessType_In, const DVRFileOperation::FileType &_FileType_In, SelectAllFileCapacityRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RecordEventStatusRequest with synchronous semantics.
     *
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void RecordEventStatusRequest(const DVRFileOperation::AccessType &_AccessType, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::RecordStatus &_RecordStatus, DVRFileOperation::EventType &_EventType, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RecordEventStatusRequest with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> RecordEventStatusRequestAsync(const DVRFileOperation::AccessType &_AccessType, RecordEventStatusRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr< DVRFileOperationProxyBase> delegate_;
};

typedef DVRFileOperationProxy<> DVRFileOperationProxyDefault;


//
// DVRFileOperationProxy Implementation
//
template <typename ... _AttributeExtensions>
DVRFileOperationProxy<_AttributeExtensions...>::DVRFileOperationProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast< DVRFileOperationProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast< DVRFileOperationProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
DVRFileOperationProxy<_AttributeExtensions...>::~DVRFileOperationProxy() {
}

template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::AllFileDeleteRequest(const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_FileDeleteACK, const CommonAPI::CallInfo *_info) {
    if (!_AccessType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_FileType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->AllFileDeleteRequest(_AccessType, _FileType, _internalCallStatus, _FileDeleteACK, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::AllFileDeleteRequestAsync(const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, AllFileDeleteRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_AccessType.validate()) {
        DVRFileOperation::SetResult FileDeleteACK = DVRFileOperation::SetResult::E_SUCCESSFUL;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileDeleteACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_FileType.validate()) {
        DVRFileOperation::SetResult FileDeleteACK = DVRFileOperation::SetResult::E_SUCCESSFUL;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileDeleteACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->AllFileDeleteRequestAsync(_AccessType, _FileType, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::FileListRequest(const DVRFileOperation::FileType &_FileType, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileNumber &_FileNumber, const DVRFileOperation::FileName &_FileName, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::FileListStructArray &_FileListStructArray, const CommonAPI::CallInfo *_info) {
    if (!_FileType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_AccessType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->FileListRequest(_FileType, _AccessType, _FileNumber, _FileName, _internalCallStatus, _FileListStructArray, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::FileListRequestAsync(const DVRFileOperation::FileType &_FileType, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileNumber &_FileNumber, const DVRFileOperation::FileName &_FileName, FileListRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_FileType.validate()) {
        DVRFileOperation::FileListStructArray FileListStructArray = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileListStructArray);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_AccessType.validate()) {
        DVRFileOperation::FileListStructArray FileListStructArray = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileListStructArray);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->FileListRequestAsync(_FileType, _AccessType, _FileNumber, _FileName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::AllFileExportRequest(const DVRFileOperation::ExportMode &_ExportMode, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::ExportFileACK &_ExportFileACK, const CommonAPI::CallInfo *_info) {
    if (!_ExportMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_AccessType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_FileType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->AllFileExportRequest(_ExportMode, _AccessType, _FileType, _internalCallStatus, _ExportFileACK, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::AllFileExportRequestAsync(const DVRFileOperation::ExportMode &_ExportMode, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, AllFileExportRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_ExportMode.validate()) {
        DVRFileOperation::ExportFileACK ExportFileACK = DVRFileOperation::ExportFileACK::E_EXPORTSUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, ExportFileACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_AccessType.validate()) {
        DVRFileOperation::ExportFileACK ExportFileACK = DVRFileOperation::ExportFileACK::E_EXPORTSUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, ExportFileACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_FileType.validate()) {
        DVRFileOperation::ExportFileACK ExportFileACK = DVRFileOperation::ExportFileACK::E_EXPORTSUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, ExportFileACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->AllFileExportRequestAsync(_ExportMode, _AccessType, _FileType, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::FileExportRequest(const DVRFileOperation::ExportMode &_ExportMode, const DVRFileOperation::FileListPath &_FileListPath, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::ExportFileACK &_ExportFileACK, const CommonAPI::CallInfo *_info) {
    if (!_ExportMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->FileExportRequest(_ExportMode, _FileListPath, _internalCallStatus, _ExportFileACK, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::FileExportRequestAsync(const DVRFileOperation::ExportMode &_ExportMode, const DVRFileOperation::FileListPath &_FileListPath, FileExportRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_ExportMode.validate()) {
        DVRFileOperation::ExportFileACK ExportFileACK = DVRFileOperation::ExportFileACK::E_EXPORTSUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, ExportFileACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->FileExportRequestAsync(_ExportMode, _FileListPath, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::AsyncAllFileDeleteRequest(const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_FileDeleteACK, const CommonAPI::CallInfo *_info) {
    if (!_AccessType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_FileType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->AsyncAllFileDeleteRequest(_AccessType, _FileType, _internalCallStatus, _FileDeleteACK, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::AsyncAllFileDeleteRequestAsync(const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileType &_FileType, AsyncAllFileDeleteRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_AccessType.validate()) {
        DVRFileOperation::SetResult FileDeleteACK = DVRFileOperation::SetResult::E_SUCCESSFUL;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileDeleteACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_FileType.validate()) {
        DVRFileOperation::SetResult FileDeleteACK = DVRFileOperation::SetResult::E_SUCCESSFUL;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileDeleteACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->AsyncAllFileDeleteRequestAsync(_AccessType, _FileType, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::DVRFileCapacityInfoReq(const DVRFileOperation::TFAllFileCapacity_Enum &_TFAllFileCapacity, const DVRFileOperation::TFCardFileTypeList_Array &_TFCardFileTypeList, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::FileCapacityList_Array &_FileCapacityList, const CommonAPI::CallInfo *_info) {
    if (!_TFAllFileCapacity.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->DVRFileCapacityInfoReq(_TFAllFileCapacity, _TFCardFileTypeList, _internalCallStatus, _FileCapacityList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::DVRFileCapacityInfoReqAsync(const DVRFileOperation::TFAllFileCapacity_Enum &_TFAllFileCapacity, const DVRFileOperation::TFCardFileTypeList_Array &_TFCardFileTypeList, DVRFileCapacityInfoReqAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_TFAllFileCapacity.validate()) {
        DVRFileOperation::FileCapacityList_Array FileCapacityList = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileCapacityList);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->DVRFileCapacityInfoReqAsync(_TFAllFileCapacity, _TFCardFileTypeList, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::SDCardFormat(const DVRFileOperation::SDCardOption &_SDCardOption, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_TFCardFormatACK, const CommonAPI::CallInfo *_info) {
    if (!_SDCardOption.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->SDCardFormat(_SDCardOption, _internalCallStatus, _TFCardFormatACK, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::SDCardFormatAsync(const DVRFileOperation::SDCardOption &_SDCardOption, SDCardFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_SDCardOption.validate()) {
        DVRFileOperation::SetResult TFCardFormatACK = DVRFileOperation::SetResult::E_SUCCESSFUL;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, TFCardFormatACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->SDCardFormatAsync(_SDCardOption, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::StartVideoBrowse(const DVRFileOperation::AccessType &_VideoBrowseChannel, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_VideoBrowseACK, const CommonAPI::CallInfo *_info) {
    if (!_VideoBrowseChannel.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->StartVideoBrowse(_VideoBrowseChannel, _internalCallStatus, _VideoBrowseACK, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::StartVideoBrowseAsync(const DVRFileOperation::AccessType &_VideoBrowseChannel, StartVideoBrowseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_VideoBrowseChannel.validate()) {
        DVRFileOperation::SetResult VideoBrowseACK = DVRFileOperation::SetResult::E_SUCCESSFUL;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, VideoBrowseACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->StartVideoBrowseAsync(_VideoBrowseChannel, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::FileListIncludeDateReq(const DVRFileOperation::FileType &_FileType, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileNumber &_FileNumber, const DVRFileOperation::FileName &_FileName, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::FileListIncludeDate_Array &_FileListIncludeDate, const CommonAPI::CallInfo *_info) {
    if (!_FileType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_AccessType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->FileListIncludeDateReq(_FileType, _AccessType, _FileNumber, _FileName, _internalCallStatus, _FileListIncludeDate, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::FileListIncludeDateReqAsync(const DVRFileOperation::FileType &_FileType, const DVRFileOperation::AccessType &_AccessType, const DVRFileOperation::FileNumber &_FileNumber, const DVRFileOperation::FileName &_FileName, FileListIncludeDateReqAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_FileType.validate()) {
        DVRFileOperation::FileListIncludeDate_Array FileListIncludeDate = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileListIncludeDate);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_AccessType.validate()) {
        DVRFileOperation::FileListIncludeDate_Array FileListIncludeDate = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, FileListIncludeDate);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->FileListIncludeDateReqAsync(_FileType, _AccessType, _FileNumber, _FileName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::FileDeleteRequest(const DVRFileOperation::FileListPath &_FileListPath, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_FileDeleteACK, const CommonAPI::CallInfo *_info) {
    delegate_->FileDeleteRequest(_FileListPath, _internalCallStatus, _FileDeleteACK, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::FileDeleteRequestAsync(const DVRFileOperation::FileListPath &_FileListPath, FileDeleteRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->FileDeleteRequestAsync(_FileListPath, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::TFCardInfoQuery(const DVRFileOperation::GetAllInfo &_GetAllInfo, const DVRFileOperation::TFCardOptionList &_TFCardOptionList, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::TFCardInfoList &_TFCardInfoList, const CommonAPI::CallInfo *_info) {
    if (!_GetAllInfo.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->TFCardInfoQuery(_GetAllInfo, _TFCardOptionList, _internalCallStatus, _TFCardInfoList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::TFCardInfoQueryAsync(const DVRFileOperation::GetAllInfo &_GetAllInfo, const DVRFileOperation::TFCardOptionList &_TFCardOptionList, TFCardInfoQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_GetAllInfo.validate()) {
        DVRFileOperation::TFCardInfoList TFCardInfoList = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, TFCardInfoList);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->TFCardInfoQueryAsync(_GetAllInfo, _TFCardOptionList, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::SelectFileCapacityRequest(const DVRFileOperation::FileListPath &_FileListPath, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_SetResult, DVRFileOperation::FileCapacity &_FileCapacity, const CommonAPI::CallInfo *_info) {
    delegate_->SelectFileCapacityRequest(_FileListPath, _internalCallStatus, _SetResult, _FileCapacity, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::SelectFileCapacityRequestAsync(const DVRFileOperation::FileListPath &_FileListPath, SelectFileCapacityRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SelectFileCapacityRequestAsync(_FileListPath, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::EMMCInfoQuery(const DVRFileOperation::GetAllInfo &_GetAllInfo, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::EMMCStatus &_EMMCStatus, DVRFileOperation::EMMCCapacityStruct &_EMMCCapacityStruct, const CommonAPI::CallInfo *_info) {
    if (!_GetAllInfo.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->EMMCInfoQuery(_GetAllInfo, _internalCallStatus, _EMMCStatus, _EMMCCapacityStruct, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::EMMCInfoQueryAsync(const DVRFileOperation::GetAllInfo &_GetAllInfo, EMMCInfoQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_GetAllInfo.validate()) {
        DVRFileOperation::EMMCStatus EMMCStatus = DVRFileOperation::EMMCStatus::E_EMMCNORMAL;
        DVRFileOperation::EMMCCapacityStruct EMMCCapacityStruct = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, EMMCStatus, EMMCCapacityStruct);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->EMMCInfoQueryAsync(_GetAllInfo, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::StopVideoBrowse(const DVRFileOperation::AccessType &_VideoBrowseChannel, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::SetResult &_VideoBrowseACK, const CommonAPI::CallInfo *_info) {
    if (!_VideoBrowseChannel.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->StopVideoBrowse(_VideoBrowseChannel, _internalCallStatus, _VideoBrowseACK, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::StopVideoBrowseAsync(const DVRFileOperation::AccessType &_VideoBrowseChannel, StopVideoBrowseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_VideoBrowseChannel.validate()) {
        DVRFileOperation::SetResult VideoBrowseACK = DVRFileOperation::SetResult::E_SUCCESSFUL;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, VideoBrowseACK);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->StopVideoBrowseAsync(_VideoBrowseChannel, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::SelectAllFileCapacityRequest(const DVRFileOperation::AccessType &_AccessType_In, const DVRFileOperation::FileType &_FileType_In, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::AccessType &_AccessType_Out, DVRFileOperation::FileType &_FileType_Out, DVRFileOperation::SelectAllFileCapacity &_SelectAllFileCapacity, const CommonAPI::CallInfo *_info) {
    if (!_AccessType_In.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_FileType_In.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->SelectAllFileCapacityRequest(_AccessType_In, _FileType_In, _internalCallStatus, _AccessType_Out, _FileType_Out, _SelectAllFileCapacity, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::SelectAllFileCapacityRequestAsync(const DVRFileOperation::AccessType &_AccessType_In, const DVRFileOperation::FileType &_FileType_In, SelectAllFileCapacityRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_AccessType_In.validate()) {
        DVRFileOperation::AccessType AccessType_Out = DVRFileOperation::AccessType::E_FORESIGHT;
        DVRFileOperation::FileType FileType_Out = DVRFileOperation::FileType::E_NORMALVIDEO;
        DVRFileOperation::SelectAllFileCapacity SelectAllFileCapacity = 0ul;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, AccessType_Out, FileType_Out, SelectAllFileCapacity);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_FileType_In.validate()) {
        DVRFileOperation::AccessType AccessType_Out = DVRFileOperation::AccessType::E_FORESIGHT;
        DVRFileOperation::FileType FileType_Out = DVRFileOperation::FileType::E_NORMALVIDEO;
        DVRFileOperation::SelectAllFileCapacity SelectAllFileCapacity = 0ul;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, AccessType_Out, FileType_Out, SelectAllFileCapacity);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->SelectAllFileCapacityRequestAsync(_AccessType_In, _FileType_In, _callback, _info);
}
template <typename ... _AttributeExtensions>
void DVRFileOperationProxy<_AttributeExtensions...>::RecordEventStatusRequest(const DVRFileOperation::AccessType &_AccessType, CommonAPI::CallStatus &_internalCallStatus, DVRFileOperation::RecordStatus &_RecordStatus, DVRFileOperation::EventType &_EventType, const CommonAPI::CallInfo *_info) {
    if (!_AccessType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->RecordEventStatusRequest(_AccessType, _internalCallStatus, _RecordStatus, _EventType, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DVRFileOperationProxy<_AttributeExtensions...>::RecordEventStatusRequestAsync(const DVRFileOperation::AccessType &_AccessType, RecordEventStatusRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_AccessType.validate()) {
        DVRFileOperation::RecordStatus RecordStatus = DVRFileOperation::RecordStatus::E_INACTIVE;
        DVRFileOperation::EventType EventType = DVRFileOperation::EventType::E_MANUALCAPTURE_BYBUTTON;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, RecordStatus, EventType);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->RecordEventStatusRequestAsync(_AccessType, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &DVRFileOperationProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool DVRFileOperationProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool DVRFileOperationProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& DVRFileOperationProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& DVRFileOperationProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace DVR_VIMS
} // namespace GREATWALL
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_GREATWALL_DVR_VIMS_DVR_File_Operation_PROXY_HPP_
