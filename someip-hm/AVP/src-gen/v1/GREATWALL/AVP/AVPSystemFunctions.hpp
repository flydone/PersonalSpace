/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.12.v202002200719.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V1_GREATWALL_AVP_AVP_SYSTEM_FUNCTIONS_HPP_
#define V1_GREATWALL_AVP_AVP_SYSTEM_FUNCTIONS_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace GREATWALL {
namespace AVP {

class AVPSystemFunctions {
public:
    virtual ~AVPSystemFunctions() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    typedef uint8_t PathNum;
    
    struct PathLotType : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            E_IDLE = 0,
            E_FIXEDPARKINGLOT = 1,
            E_RANDOMPARKINGLOT = 2,
            E_RESERVED = 3
        };
    
        PathLotType()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::E_IDLE)) {}
        PathLotType(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::E_IDLE):
                case static_cast< uint8_t>(Literal::E_FIXEDPARKINGLOT):
                case static_cast< uint8_t>(Literal::E_RANDOMPARKINGLOT):
                case static_cast< uint8_t>(Literal::E_RESERVED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PathLotType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PathLotType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PathLotType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PathLotType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PathLotType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PathLotType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    };
    typedef float distance;
    typedef std::string name;
    typedef uint16_t total_num;
    typedef uint16_t id;
    typedef uint16_t idle_num;
    typedef float lat;
    typedef std::string address;
    typedef std::string floors;
    typedef float lon;
    struct ParkingListStruct : CommonAPI::Struct< id, name, address, lon, lat, distance, idle_num, total_num, floors> {
    
        ParkingListStruct()
        {
            std::get< 0>(values_) = id();
            std::get< 1>(values_) = name();
            std::get< 2>(values_) = address();
            std::get< 3>(values_) = lon();
            std::get< 4>(values_) = lat();
            std::get< 5>(values_) = distance();
            std::get< 6>(values_) = idle_num();
            std::get< 7>(values_) = total_num();
            std::get< 8>(values_) = floors();
        }
        ParkingListStruct(const id &_id, const name &_name, const address &_address, const lon &_lon, const lat &_lat, const distance &_distance, const idle_num &_idle_num, const total_num &_total_num, const floors &_floors)
        {
            std::get< 0>(values_) = _id;
            std::get< 1>(values_) = _name;
            std::get< 2>(values_) = _address;
            std::get< 3>(values_) = _lon;
            std::get< 4>(values_) = _lat;
            std::get< 5>(values_) = _distance;
            std::get< 6>(values_) = _idle_num;
            std::get< 7>(values_) = _total_num;
            std::get< 8>(values_) = _floors;
        }
        inline const id &getId() const { return std::get< 0>(values_); }
        inline void setId(const id &_value) { std::get< 0>(values_) = _value; }
        inline const name &getName() const { return std::get< 1>(values_); }
        inline void setName(const name &_value) { std::get< 1>(values_) = _value; }
        inline const address &getAddress() const { return std::get< 2>(values_); }
        inline void setAddress(const address &_value) { std::get< 2>(values_) = _value; }
        inline const lon &getLon() const { return std::get< 3>(values_); }
        inline void setLon(const lon &_value) { std::get< 3>(values_) = _value; }
        inline const lat &getLat() const { return std::get< 4>(values_); }
        inline void setLat(const lat &_value) { std::get< 4>(values_) = _value; }
        inline const distance &getDistance() const { return std::get< 5>(values_); }
        inline void setDistance(const distance &_value) { std::get< 5>(values_) = _value; }
        inline const idle_num &getIdle_num() const { return std::get< 6>(values_); }
        inline void setIdle_num(const idle_num &_value) { std::get< 6>(values_) = _value; }
        inline const total_num &getTotal_num() const { return std::get< 7>(values_); }
        inline void setTotal_num(const total_num &_value) { std::get< 7>(values_) = _value; }
        inline const floors &getFloors() const { return std::get< 8>(values_); }
        inline void setFloors(const floors &_value) { std::get< 8>(values_) = _value; }
        inline bool operator==(const ParkingListStruct& _other) const {
        return (getId() == _other.getId() && getName() == _other.getName() && getAddress() == _other.getAddress() && getLon() == _other.getLon() && getLat() == _other.getLat() && getDistance() == _other.getDistance() && getIdle_num() == _other.getIdle_num() && getTotal_num() == _other.getTotal_num() && getFloors() == _other.getFloors());
        }
        inline bool operator!=(const ParkingListStruct &_other) const {
            return !((*this) == _other);
        }
    
    };
    typedef std::vector< AVPSystemFunctions::ParkingListStruct> ParkingListStructArray;
    
    struct HUTRequest : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            E_RESERVED = 0,
            E_REQUEST = 1
        };
    
        HUTRequest()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::E_RESERVED)) {}
        HUTRequest(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::E_RESERVED):
                case static_cast< uint8_t>(Literal::E_REQUEST):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const HUTRequest &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const HUTRequest &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const HUTRequest &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const HUTRequest &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const HUTRequest &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const HUTRequest &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    };
    typedef std::string PathName;
    
    struct ParkingListResponseNACK : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            E_FAILED_NETWORK = 0,
            E_RESERVED = 1
        };
    
        ParkingListResponseNACK()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::E_FAILED_NETWORK)) {}
        ParkingListResponseNACK(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::E_FAILED_NETWORK):
                case static_cast< uint8_t>(Literal::E_RESERVED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ParkingListResponseNACK &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ParkingListResponseNACK &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ParkingListResponseNACK &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ParkingListResponseNACK &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ParkingListResponseNACK &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ParkingListResponseNACK &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    };
    
    struct PathType : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            E_IDLE = 0,
            E_PARKINGINTYPE = 1,
            E_PARKINGOUTTYPE = 2,
            E_RESERVED = 3
        };
    
        PathType()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::E_IDLE)) {}
        PathType(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::E_IDLE):
                case static_cast< uint8_t>(Literal::E_PARKINGINTYPE):
                case static_cast< uint8_t>(Literal::E_PARKINGOUTTYPE):
                case static_cast< uint8_t>(Literal::E_RESERVED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PathType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PathType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PathType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PathType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PathType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PathType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    };
    
    struct PathInfoOperation : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            E_DELETE = 0,
            E_SETTOP = 1,
            E_RENAME = 2
        };
    
        PathInfoOperation()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::E_DELETE)) {}
        PathInfoOperation(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::E_DELETE):
                case static_cast< uint8_t>(Literal::E_SETTOP):
                case static_cast< uint8_t>(Literal::E_RENAME):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PathInfoOperation &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PathInfoOperation &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PathInfoOperation &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PathInfoOperation &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PathInfoOperation &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PathInfoOperation &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    };
    typedef std::vector< uint8_t> PathPic;
    typedef uint8_t PathDistance;
    typedef uint8_t PathLearnRate;
    
    struct PathStatus : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            E_IDLE = 0,
            E_VALIDPATH = 1,
            E_LEARNINGINPROCESSPATH = 2,
            E_INVALIDPATH = 3
        };
    
        PathStatus()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::E_IDLE)) {}
        PathStatus(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::E_IDLE):
                case static_cast< uint8_t>(Literal::E_VALIDPATH):
                case static_cast< uint8_t>(Literal::E_LEARNINGINPROCESSPATH):
                case static_cast< uint8_t>(Literal::E_INVALIDPATH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PathStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PathStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PathStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PathStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PathStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PathStatus &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    };
    typedef uint8_t PathId;
    struct PathInfoStruct : CommonAPI::Struct< PathId, PathNum, PathType, PathLotType, PathStatus, PathLearnRate, PathDistance, PathName, PathPic> {
    
        PathInfoStruct()
        {
            std::get< 0>(values_) = PathId();
            std::get< 1>(values_) = PathNum();
            std::get< 2>(values_) = PathType();
            std::get< 3>(values_) = PathLotType();
            std::get< 4>(values_) = PathStatus();
            std::get< 5>(values_) = PathLearnRate();
            std::get< 6>(values_) = PathDistance();
            std::get< 7>(values_) = PathName();
            std::get< 8>(values_) = PathPic();
        }
        PathInfoStruct(const PathId &_PathId, const PathNum &_PathNum, const PathType &_PathType, const PathLotType &_PathLotType, const PathStatus &_PathStatus, const PathLearnRate &_PathLearnRate, const PathDistance &_PathDistance, const PathName &_PathName, const PathPic &_PathPic)
        {
            std::get< 0>(values_) = _PathId;
            std::get< 1>(values_) = _PathNum;
            std::get< 2>(values_) = _PathType;
            std::get< 3>(values_) = _PathLotType;
            std::get< 4>(values_) = _PathStatus;
            std::get< 5>(values_) = _PathLearnRate;
            std::get< 6>(values_) = _PathDistance;
            std::get< 7>(values_) = _PathName;
            std::get< 8>(values_) = _PathPic;
        }
        inline const PathId &getPathId() const { return std::get< 0>(values_); }
        inline void setPathId(const PathId &_value) { std::get< 0>(values_) = _value; }
        inline const PathNum &getPathNum() const { return std::get< 1>(values_); }
        inline void setPathNum(const PathNum &_value) { std::get< 1>(values_) = _value; }
        inline const PathType &getPathType() const { return std::get< 2>(values_); }
        inline void setPathType(const PathType &_value) { std::get< 2>(values_) = _value; }
        inline const PathLotType &getPathLotType() const { return std::get< 3>(values_); }
        inline void setPathLotType(const PathLotType &_value) { std::get< 3>(values_) = _value; }
        inline const PathStatus &getPathStatus() const { return std::get< 4>(values_); }
        inline void setPathStatus(const PathStatus &_value) { std::get< 4>(values_) = _value; }
        inline const PathLearnRate &getPathLearnRate() const { return std::get< 5>(values_); }
        inline void setPathLearnRate(const PathLearnRate &_value) { std::get< 5>(values_) = _value; }
        inline const PathDistance &getPathDistance() const { return std::get< 6>(values_); }
        inline void setPathDistance(const PathDistance &_value) { std::get< 6>(values_) = _value; }
        inline const PathName &getPathName() const { return std::get< 7>(values_); }
        inline void setPathName(const PathName &_value) { std::get< 7>(values_) = _value; }
        inline const PathPic &getPathPic() const { return std::get< 8>(values_); }
        inline void setPathPic(const PathPic &_value) { std::get< 8>(values_) = _value; }
        inline bool operator==(const PathInfoStruct& _other) const {
        return (getPathId() == _other.getPathId() && getPathNum() == _other.getPathNum() && getPathType() == _other.getPathType() && getPathLotType() == _other.getPathLotType() && getPathStatus() == _other.getPathStatus() && getPathLearnRate() == _other.getPathLearnRate() && getPathDistance() == _other.getPathDistance() && getPathName() == _other.getPathName() && getPathPic() == _other.getPathPic());
        }
        inline bool operator!=(const PathInfoStruct &_other) const {
            return !((*this) == _other);
        }
    
    };
    typedef std::vector< AVPSystemFunctions::PathInfoStruct> PathInfoStructArray;
    
    struct GeoFenceResponse : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            E_OUTSIDE = 0,
            E_INSIDE = 1,
            E_PAVPSYSTEMUNAVALIABLE = 2
        };
    
        GeoFenceResponse()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::E_OUTSIDE)) {}
        GeoFenceResponse(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::E_OUTSIDE):
                case static_cast< uint8_t>(Literal::E_INSIDE):
                case static_cast< uint8_t>(Literal::E_PAVPSYSTEMUNAVALIABLE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GeoFenceResponse &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GeoFenceResponse &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GeoFenceResponse &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GeoFenceResponse &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GeoFenceResponse &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GeoFenceResponse &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    };
};

const char* AVPSystemFunctions::getInterface() {
    return ("GREATWALL.AVP.AVPSystemFunctions:v1_0");
}

CommonAPI::Version AVPSystemFunctions::getInterfaceVersion() {
    return CommonAPI::Version(1, 0);
}


} // namespace AVP
} // namespace GREATWALL
} // namespace v1

namespace CommonAPI {
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_GREATWALL_AVP_AVP_SYSTEM_FUNCTIONS_HPP_
